# Нормализация состояния

Во многих приложениях используются вложенные или связанные структуры данных. Например, редактор блога может содержать много _постов_ с большим количеством _комментариев_. И те, и другие - _посты_ и _комментарии_ - написаны _пользователем_. Структура хранилища для такого приложения может выглядеть вот так:

```js
const blogPosts = [
    {
        id : "post1",
        author : {username : "user1", name : "User 1"},
        body : "......",
        comments : [
            {
				id : "comment1",
				author : {username : "user2", name : "User 2"},
				comment : ".....",
			},
			{
				id : "comment2",
				author : {username : "user3", name : "User 3"},
				comment : ".....",
			}
        ]
    },
	{
        id : "post2",
        author : {username : "user2", name : "User 2"},
        body : "......",
        comments : [
            {
				id : "comment3",
				author : {username : "user3", name : "User 3"},
				comment : ".....",
			},
			{
				id : "comment4",
				author : {username : "user1", name : "User 1"},
				comment : ".....",
			},
			{
				id : "comment5",
				author : {username : "user3", name : "User 3"},
				comment : ".....",
			}
        ]
    }
    // and repeat many times
]
```

Заметьте, что такая структура немного сложна, и некоторые данные повторяются. Из-за этого могут возникнуть следующие проблемы:

- Повторяющиеся данные сложно обновлять, поскольку одинаковые правки нужно вносить сразу в нескольких местах.
- Из-за вложенных данных код редьюсера становится тоже более древовидным и сложным. В частности, обновление глубоко лежащих данных внутри древовидной структуры может быстро превратить ваш код в трудночитаемую мешанину.
- Неизменяемые типы данных требуют для всех своих прародителей в дереве состояния правильного копирования и обновления. Из-за создания новых ссылок на объекты вызывается перерисовка у присоединенных UI компонентов. Обновление глубоко вложенной структуры данных может спровоцировать перерисовку UI компонентов, даже если реальные данные, которые они отображают, не обновились.

Поэтому рекомендуемый подход для управления связанности и вложенности данных в Redux хранилище - это обращаение с данными, как если бы они хранились в базе данных, и хранение их в _нормализованном_ виде.


## Проектирование нормализованного состояния

Основные концепции нормализации данных:

- Каждый тип данных получает свою собственную “таблицу” в структуре состояния.
- Каждая “таблица данных” должна хранить элементы в объекте, где ключами являются идентификаторы объектов, а значениями - сами элементы.
- Любые ссылки на элементы должны осуществляться путем указания идентификатора этого элемента.
- Массивы идентификаторов используются, чтобы задать очередность следования элементов.

Измененный пример блога с нормализованной структурой состояния может выглядеть следующим образом:

```js
{
    posts : {
        byId : {
            "post1" : {
                id : "post1",
				author : "user1",
				body : "......",
				comments : ["comment1", "comment2"]
            },
            "post2" : {
				id : "post2",
				author : "user2",
				body : "......",
				comments : ["comment3", "comment4", "comment5"]
            }
        }
        allIds : ["post1", "post2"]
    },
    comments : {
        byId : {
            "comment1" : {
                id : "comment1",
                author : "user2",
                comment : ".....",
            },
            "comment2" : {
                id : "comment2",
                author : "user3",
                comment : ".....",
            },
            "comment3" : {
                id : "comment3",
                author : "user3",
                comment : ".....",
            },
            "comment4" : {
                id : "comment4",
                author : "user1",
                comment : ".....",
            },
            "comment5" : {
                id : "comment5",
                author : "user3",
                comment : ".....",
            },
        },
        allIds : ["comment1", "comment2", "comment3", "commment4", "comment5"]
    },
    users : {
        byId : {
            "user1" : {
                username : "user1",
                name : "User 1",
            }
            "user2" : {
                username : "user2",
                name : "User 2",
            }
            "user3" : {
                username : "user3",
                name : "User 3",
            }
        },
        allIds : ["user1", "user2", "user3"]
    }
}
```

Общая структура стала более плоской. По сравнению с изначальной версией наблюдается несколько улучшений:

- Поскольку каждый элемент описан только в одном месте, нам не нужно будет его обновлять в нескольких местах, когда такая необходимость возникнет.
- Редьюсеру не придется иметь дело с глубоко вложенными данными, поэтому его код будет значительно проще.
- Логика извлечения и обновления данных теперь очень простая и консистентная. Имея тип элемента и его идентификатор, элемент можно легко найти без необходимости рыться во внутренностях других объектов.
- Так как данные разделены, то для обновления вроде изменения текста комментария нужно скопировать и изменить только "comments > byId > comment" часть дерева состояния. В общем случае это означает уменьшение лишних перерисовок UI компонентов, происходящих из-за обновления состояния приложения. Для сравнения: обновление комментария в изначальном варианте со вложенной структурой вызовет обновление объекта comment, родительского объекта post, всего массива с объектами типа post и, скорее всего, вызовет перерисовку _всех_ Post и Comment компонентов интерфейса.

Имейте в виду, нормализация в общем случае подразумевает, что большее количество компонентов будет присоединено к хранилищу, но брать из него они будуь лишь небольшую часть необходимых данных. В то время как первоначальный вариант со вложенной структурой, наоборот, подразумевает малое количество присоединенных компонентов, но они должны брать большой кусок хранилища и передавать их дальше по иерархии. Итого, если подключить родительский компонент к хранилищу и просто передать идентификаторы элементов дочерним компонентам, которые тоже присоединены к хранилищу, это увеличит скорость работы в React Redux приложении. Сохранение состояния приложения нормализованным является хорошим шаблоном проектирования и играет ключевую роль в улучшении производительности приложения.


## Организация нормализованных данных в состоянии

Обычное приложение, скорее всего, будет иметь смесь связанных и несвязанных данных. Нет четкого правила, как хранить различные типы данных, но есть один очень распространенный шаблон их организации, при котором все связанные “таблицы” помещаются в один общий объект entities. Это может выглядеть так:

```js
{
    simpleDomainData1: {....},
    simpleDomainData2: {....}
    entities : {
        entityType1 : {....},
        entityType2 : {....}
    }
    ui : {
        uiSection1 : {....},
        uiSection2 : {....}
    }
}
```

Эта схема может быть расширена. Например, в приложении, в котором часто происходит редактирование в объекте entities, можно создать два набора “таблиц” в хранилище: одно “current” для текущих элементов, другое "work-in-progress" для элементов, которые находятся в состоянии редактирования. Когда элемент редактируется, его значения копируются в "work-in-progress" область, и любые действия будут применены именно к этой копии, позволяя редактируемой форме управлять ими. В то время как другие UI компоненты будут ссылаться на еще не измененную оригинальную версию элемента. Чтобы сбросить изменения в редактируемой форме, достаточно снова скопировать оригинальный объект из “current” области в "work-in-progress". Если же нужно применить изменения из редактируемой формы, то нужно сделать обратную операцию.


## Связи и таблицы

Обращение с Redux хранилищем как с базой данных позволяет использовать многие техники дизайна баз данных. К примеру, если мы имеем связь многие-ко-многим, мы можем сразу спроектировать вспомогательную таблицу, которая хранит идентификаторы соответствующих элементов (также известную как “join таблицу” или “ассоциативную таблицу”). Для единообразия мы, возможно, захотим использовать те же ключи `byId` и `allIds`, которые мы использовали для оригинальных “таблиц”. Например:

```js
{
    entities: {
        authors : { byId : {}, allIds : [] },
        books : { byId : {}, allIds : [] },
        authorBook : {
            byId : {
                1 : {
                    id : 1,
                    authorId : 5,
                    bookId : 22
                },
                2 : {
                    id : 2,
                    authorId : 5,
                    bookId : 15,
                }
                3 : {
                    id : 3,
                    authorId : 42,
                    bookId : 12
                }
            },
            allIds : [1, 2, 3]
        }
    }
}
```

Операции типа “Найти все книги этого автора” могут быть осуществлены одним циклом с помощью join таблицы. Такого рода операции имеют достаточно хорошую скорость в большинстве случаев.


## Нормализация вложенных данных

Так как API’и часто возвращают нас к вложенным структурам, получаемые данные надо нормализовать перед тем, как обновлять состояние приложения. Для этого часто используют библиотеку [Normalizr](https://github.com/paularmstrong/normalizr). Вы можете определить схему типов элементов и их связи, передать эту схему вместе с полученными данными в Normalizr и на выходе получить уже нормализованные данные. Этот вывод уже может быть помещен в action и использоваться для обновления состояния. Посмотрите документацию Normalizr, чтобы получить больше информации по его использованию.
